<!-- _includes/load_model.html -->
<div id="model-container" style="background: transparent;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/modifiers/SimplifyModifier.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // 'alpha: true' makes the background transparent
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // The second parameter (0) sets the transparency of the clear color
        document.getElementById('model-container').appendChild(renderer.domElement);

        // Orbit Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smoothes the movement
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2;
        controls.enableZoom = false; // Disable zoom to ensure scrolling only affects the page

        let isUserInteracting = false;
        let interactionTimeout;

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        // Load the 3D model (GLTF format) asynchronously when the browser is idle
        function loadModel() {
            const loader = new THREE.GLTFLoader();
            const gltfPaths = '{{ include.gltf_paths }}'.split(',');

            // Select a random path from the array
            const randomIndex = Math.floor(Math.random() * gltfPaths.length);
            const selectedGltfPath = gltfPaths[randomIndex].trim();

            loader.load(selectedGltfPath, function (gltf) {
                let model = gltf.scene;

                // Simplify the geometry
                model.traverse(function(child) {
                    if (child.isMesh) {
                        const modifier = new THREE.SimplifyModifier();
                        const simplifiedGeometry = modifier.modify(child.geometry, Math.floor(child.geometry.attributes.position.count * 0.3));
                        child.geometry = simplifiedGeometry;
                        child.material = new THREE.MeshBasicMaterial({ color: 0xaaeeFF, wireframe: true });
                    }
                });

                // Scale the model
                const scale = parseFloat('{{ include.scale | default: 1 }}');
                model.scale.set(scale, scale, scale);

                // Add the simplified model to the scene
                scene.add(model);

                // Position the camera
                camera.position.z = 5;

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);

                    // Rotate model only if user is not interacting
                    if (!isUserInteracting && model) {
                        model.rotation.y += 0.01;
                    }

                    controls.update(); // Required for controls.enableDamping
                    renderer.render(scene, camera);
                }
                animate();

                // Detect when user starts interacting
                controls.addEventListener('start', function () {
                    isUserInteracting = true;
                    clearTimeout(interactionTimeout);
                });

                // Detect when user stops interacting, then resume animation after a delay
                controls.addEventListener('end', function () {
                    clearTimeout(interactionTimeout);
                    interactionTimeout = setTimeout(function () {
                        isUserInteracting = false;
                    }, 2000); // Adjust the delay as needed (2 seconds here)
                });
            }, undefined, function (error) {
                console.error('An error happened during model loading:', error);
            });
        }

        // Use requestIdleCallback to load the model without blocking the main thread
        if ('requestIdleCallback' in window) {
            requestIdleCallback(loadModel);
        } else {
            // Fallback if requestIdleCallback is not supported
            setTimeout(loadModel, 200);
        }

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }, 200); // Adjust the timeout value as needed
        });

    });
</script>

